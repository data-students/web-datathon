import {
  DEV,
  get,
  is_void,
  set,
  source,
  store_invalid_shape,
  svelte_element_invalid_this_value
} from "./chunk-WRN2CC2L.js";
import {
  get_prototype_of,
  is_array,
  object_prototype
} from "./chunk-ZHNMYN2P.js";

// node_modules/svelte/src/internal/shared/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function dynamic_void_element_content(tag) {
  if (DEV) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag}">\` is a void element — it cannot have content`, bold, normal);
  } else {
    console.warn("dynamic_void_element_content");
  }
}
function state_snapshot_uncloneable(properties) {
  if (DEV) {
    console.warn(`%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` — the original value was returned"}`, bold, normal);
  } else {
    console.warn("state_snapshot_uncloneable");
  }
}

// node_modules/svelte/src/internal/shared/clone.js
var empty = [];
function snapshot(value, skip_warning = false) {
  if (DEV) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths);
    if (paths.length === 1 && paths[0] === "" && !skip_warning) {
      state_snapshot_uncloneable();
    } else if (paths.length > 0 && !skip_warning) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty);
}
function clone(value, cloned, path, paths) {
  if (typeof value === "object" && value !== null) {
    const unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (is_array(value)) {
      const copy = (
        /** @type {Snapshot<any>} */
        []
      );
      cloned.set(value, copy);
      for (let i = 0; i < value.length; i += 1) {
        copy.push(clone(value[i], cloned, DEV ? `${path}[${i}]` : path, paths));
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      const copy = {};
      cloned.set(value, copy);
      for (var key in value) {
        copy[key] = clone(value[key], cloned, DEV ? `${path}.${key}` : path, paths);
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function") {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        DEV ? `${path}.toJSON()` : path,
        paths
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (DEV) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
function reactive_import(fn) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function bubble_event($$props, event) {
  var _a;
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    (_a = $$props.$$events) == null ? void 0 : _a[event.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event);
  }
}
function add_legacy_event_listener($$props, event_name, event_callback) {
  var _a;
  $$props.$$events || ($$props.$$events = {});
  (_a = $$props.$$events)[event_name] || (_a[event_name] = []);
  $$props.$$events[event_name].push(event_callback);
}
function update_legacy_props($$new_props) {
  for (var key in $$new_props) {
    if (key in this) {
      this[key] = $$new_props[key];
    }
  }
}
function default_slot($$props) {
  var _a;
  var children = (_a = $$props.$$slots) == null ? void 0 : _a.default;
  if (children === true) {
    return $$props.children;
  } else {
    return children;
  }
}

// node_modules/svelte/src/internal/shared/validate.js
function validate_void_dynamic_element(tag_fn) {
  const tag = tag_fn();
  if (tag && is_void(tag)) {
    dynamic_void_element_content(tag);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag = tag_fn();
  const is_string = typeof tag === "string";
  if (tag && !is_string) {
    svelte_element_invalid_this_value();
  }
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    store_invalid_shape(name);
  }
}

// node_modules/svelte/src/utils.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}

export {
  snapshot,
  hash,
  reactive_import,
  bubble_event,
  add_legacy_event_listener,
  update_legacy_props,
  default_slot,
  validate_void_dynamic_element,
  validate_dynamic_element_tag,
  validate_store
};
//# sourceMappingURL=chunk-V7U52PMA.js.map
