{
  "version": 3,
  "sources": ["../../svelte/src/internal/shared/warnings.js", "../../svelte/src/internal/shared/clone.js", "../../svelte/src/internal/client/dom/legacy/misc.js", "../../svelte/src/internal/shared/validate.js", "../../svelte/src/utils.js"],
  "sourcesContent": ["/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\nvar bold = 'font-weight: bold';\nvar normal = 'font-weight: normal';\n\n/**\n * `<svelte:element this=\"%tag%\">` is a void element — it cannot have content\n * @param {string} tag\n */\nexport function dynamic_void_element_content(tag) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] dynamic_void_element_content\\n%c\\`<svelte:element this=\"${tag}\">\\` is a void element — it cannot have content`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"dynamic_void_element_content\");\n\t}\n}\n\n/**\n * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:\n * \n * %properties%\n * @param {string | undefined | null} [properties]\n */\nexport function state_snapshot_uncloneable(properties) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] state_snapshot_uncloneable\\n%c${properties\n\t\t\t? `The following properties cannot be cloned with \\`$state.snapshot\\` — the return value contains the originals:\n\n${properties}`\n\t\t\t: \"Value cannot be cloned with `$state.snapshot` — the original value was returned\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"state_snapshot_uncloneable\");\n\t}\n}", "/** @import { Snapshot } from './types' */\nimport { DEV } from 'esm-env';\nimport * as w from './warnings.js';\nimport { get_prototype_of, is_array, object_prototype } from './utils.js';\n\n/**\n * In dev, we keep track of which properties could not be cloned. In prod\n * we don't bother, but we keep a dummy array around so that the\n * signature stays the same\n * @type {string[]}\n */\nconst empty = [];\n\n/**\n * @template T\n * @param {T} value\n * @param {boolean} [skip_warning]\n * @returns {Snapshot<T>}\n */\nexport function snapshot(value, skip_warning = false) {\n\tif (DEV) {\n\t\t/** @type {string[]} */\n\t\tconst paths = [];\n\n\t\tconst copy = clone(value, new Map(), '', paths);\n\t\tif (paths.length === 1 && paths[0] === '' && !skip_warning) {\n\t\t\t// value could not be cloned\n\t\t\tw.state_snapshot_uncloneable();\n\t\t} else if (paths.length > 0 && !skip_warning) {\n\t\t\t// some properties could not be cloned\n\t\t\tconst slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);\n\t\t\tconst excess = paths.length - slice.length;\n\n\t\t\tlet uncloned = slice.map((path) => `- <value>${path}`).join('\\n');\n\t\t\tif (excess > 0) uncloned += `\\n- ...and ${excess} more`;\n\n\t\t\tw.state_snapshot_uncloneable(uncloned);\n\t\t}\n\n\t\treturn copy;\n\t}\n\n\treturn clone(value, new Map(), '', empty);\n}\n\n/**\n * @template T\n * @param {T} value\n * @param {Map<T, Snapshot<T>>} cloned\n * @param {string} path\n * @param {string[]} paths\n * @returns {Snapshot<T>}\n */\nfunction clone(value, cloned, path, paths) {\n\tif (typeof value === 'object' && value !== null) {\n\t\tconst unwrapped = cloned.get(value);\n\t\tif (unwrapped !== undefined) return unwrapped;\n\n\t\tif (is_array(value)) {\n\t\t\tconst copy = /** @type {Snapshot<any>} */ ([]);\n\t\t\tcloned.set(value, copy);\n\n\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\tcopy.push(clone(value[i], cloned, DEV ? `${path}[${i}]` : path, paths));\n\t\t\t}\n\n\t\t\treturn copy;\n\t\t}\n\n\t\tif (get_prototype_of(value) === object_prototype) {\n\t\t\t/** @type {Snapshot<any>} */\n\t\t\tconst copy = {};\n\t\t\tcloned.set(value, copy);\n\n\t\t\tfor (var key in value) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tcopy[key] = clone(value[key], cloned, DEV ? `${path}.${key}` : path, paths);\n\t\t\t}\n\n\t\t\treturn copy;\n\t\t}\n\n\t\tif (value instanceof Date) {\n\t\t\treturn /** @type {Snapshot<T>} */ (structuredClone(value));\n\t\t}\n\n\t\tif (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function') {\n\t\t\treturn clone(\n\t\t\t\t/** @type {T & { toJSON(): any } } */ (value).toJSON(),\n\t\t\t\tcloned,\n\t\t\t\tDEV ? `${path}.toJSON()` : path,\n\t\t\t\tpaths\n\t\t\t);\n\t\t}\n\t}\n\n\tif (value instanceof EventTarget) {\n\t\t// can't be cloned\n\t\treturn /** @type {Snapshot<T>} */ (value);\n\t}\n\n\ttry {\n\t\treturn /** @type {Snapshot<T>} */ (structuredClone(value));\n\t} catch (e) {\n\t\tif (DEV) {\n\t\t\tpaths.push(path);\n\t\t}\n\n\t\treturn /** @type {Snapshot<T>} */ (value);\n\t}\n}\n", "import { set, source } from '../../reactivity/sources.js';\nimport { get } from '../../runtime.js';\nimport { is_array } from '../../../shared/utils.js';\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tvar s = source(0);\n\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * Used to simulate `$on` on a component instance when `compatibility.componentApi === 4`\n * @param {Record<string, any>} $$props\n * @param {string} event_name\n * @param {Function} event_callback\n */\nexport function add_legacy_event_listener($$props, event_name, event_callback) {\n\t$$props.$$events ||= {};\n\t$$props.$$events[event_name] ||= [];\n\t$$props.$$events[event_name].push(event_callback);\n}\n\n/**\n * Used to simulate `$set` on a component instance when `compatibility.componentApi === 4`.\n * Needs component accessors so that it can call the setter of the prop. Therefore doesn't\n * work for updating props in `$$props` or `$$restProps`.\n * @this {Record<string, any>}\n * @param {Record<string, any>} $$new_props\n */\nexport function update_legacy_props($$new_props) {\n\tfor (var key in $$new_props) {\n\t\tif (key in this) {\n\t\t\tthis[key] = $$new_props[key];\n\t\t}\n\t}\n}\n\n/**\n * @param {Record<string, any>} $$props\n */\nexport function default_slot($$props) {\n\tvar children = $$props.$$slots?.default;\n\tif (children === true) {\n\t\treturn $$props.children;\n\t} else {\n\t\treturn children;\n\t}\n}\n", "/** @import { TemplateNode } from '#client' */\n/** @import { Getters } from '#shared' */\nimport { is_void } from '../../constants.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\n\nexport { invalid_default_snippet } from './errors.js';\n\n/**\n * @param {() => string} tag_fn\n * @returns {void}\n */\nexport function validate_void_dynamic_element(tag_fn) {\n\tconst tag = tag_fn();\n\tif (tag && is_void(tag)) {\n\t\tw.dynamic_void_element_content(tag);\n\t}\n}\n\n/** @param {() => unknown} tag_fn */\nexport function validate_dynamic_element_tag(tag_fn) {\n\tconst tag = tag_fn();\n\tconst is_string = typeof tag === 'string';\n\tif (tag && !is_string) {\n\t\te.svelte_element_invalid_this_value();\n\t}\n}\n\n/**\n * @param {any} store\n * @param {string} name\n */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\te.store_invalid_shape(name);\n\t}\n}\n", "const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n"],
  "mappings": "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",
  "names": ["hash"]
}
